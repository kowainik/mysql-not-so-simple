module MySql.Row
       ( Row (..)
       ) where

import MySql.Field (Field (..))

import qualified Database.MySQL.Base as SQL
import qualified System.IO.Streams as Stream

{- | Something that can be represented as a row. We define this manually since
there is no @FromRow@ or @ToRow@ in @mysql-haskell@.
-}
class Row a where
    toRow   :: a -> [SQL.Param]
    fromRow :: [SQL.MySQLValue] -> Maybe a

newtype Only a = Only
    { fromOnly :: a
    } deriving (Eq, Ord, Read, Show)

instance (Field a) => Row (Only a) where
    toRow (Only a) = [toField a]
    fromRow [a] = Only <$> fromC a
    fromRow _   = Nothing

instance (Field a, Field b) => Row (a,b) where
    toRow (a,b) = [toField a, toField b]
    fromRow [a,b] = (,) <$> fromC a <*> fromC b
    fromRow _     = Nothing

instance (Field a, Field b, Field c) => Row (a,b,c) where
    toRow (a,b,c) = [toField a, toField b, toField c]
    fromRow [a,b,c] = (,,) <$> fromC a <*> fromC b <*> fromC c
    fromRow _       = Nothing

instance (Field a, Field b, Field c, Field d) => Row (a,b,c,d) where
    toRow (a,b,c,d) = [toField a, toField b, toField c, toField d]
    fromRow [a,b,c,d] = (,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d
    fromRow _         = Nothing

instance (Field a, Field b, Field c, Field d, Field e) => Row (a,b,c,d,e) where
    toRow (a,b,c,d,e) = [toField a, toField b, toField c, toField d, toField e]
    fromRow [a,b,c,d,e] = (,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e
    fromRow _           = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f) => Row (a,b,c,d,e,f) where
    toRow (a,b,c,d,e,f) = [toField a, toField b, toField c, toField d, toField e, toField f]
    fromRow [a,b,c,d,e,f] = (,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g) => Row (a,b,c,d,e,f,g) where
    toRow (a,b,c,d,e,f,g) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g]
    fromRow [a,b,c,d,e,f,g] = (,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h) => Row (a,b,c,d,e,f,g,h) where
    toRow (a,b,c,d,e,f,g,h) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h]
    fromRow [a,b,c,d,e,f,g,h] = (,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i) => Row (a,b,c,d,e,f,g,h,i) where
    toRow (a,b,c,d,e,f,g,h,i) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i]
    fromRow [a,b,c,d,e,f,g,h,i] = (,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i, Field j) => Row (a,b,c,d,e,f,g,h,i,j) where
    toR (a,b,c,d,e,f,g,h,i,j) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i, toField j]
    fromRow [a,b,c,d,e,f,g,h,i,j] = (,,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i <*> fromC j
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i, Field j, Field k) => Row (a,b,c,d,e,f,g,h,i,j,k) where
    toRow (a,b,c,d,e,f,g,h,i,j,k) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i, toField j, toField k]
    fromRow [a,b,c,d,e,f,g,h,i,j,k] = (,,,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i <*> fromC j <*> fromC k
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i, Field j, Field k, Field l) => Row (a,b,c,d,e,f,g,h,i,j,k,l) where
    toRow (a,b,c,d,e,f,g,h,i,j,k,l) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i, toField j, toField k, toField l]
    fromRow [a,b,c,d,e,f,g,h,i,j,k,l] = (,,,,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i <*> fromC j <*> fromC k <*> fromC l
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i, Field j, Field k, Field l, Field m) => Row (a,b,c,d,e,f,g,h,i,j,k,l,m) where
    toR (a,b,c,d,e,f,g,h,i,j,k,l,m) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i, toField j, toField k, toField l, toField m]
    fromR [a,b,c,d,e,f,g,h,i,j,k,l,m] = (,,,,,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i <*> fromC j <*> fromC k <*> fromC l <*> fromC m
    fromR _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i, Field j, Field k, Field l, Field m, Field n) => Row (a,b,c,d,e,f,g,h,i,j,k,l,m,n) where
    toRow (a,b,c,d,e,f,g,h,i,j,k,l,m,n) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i, toField j, toField k, toField l, toField m, toField n]
    fromRow [a,b,c,d,e,f,g,h,i,j,k,l,m,n] = (,,,,,,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i <*> fromC j <*> fromC k <*> fromC l <*> fromC m <*> fromC n
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i, Field j, Field k, Field l, Field m, Field n, Field o) => Row (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) where
    toRow (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i, toField j, toField k, toField l, toField m, toField n, toField o]
    fromRow [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o] = (,,,,,,,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i <*> fromC j <*> fromC k <*> fromC l <*> fromC m <*> fromC n <*> fromC o
    fromRow _ = Nothing

instance (Field a, Field b, Field c, Field d, Field e, Field f, Field g, Field h, Field i, Field j, Field k, Field l, Field m, Field n, Field o, Field p) => Row (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) where
    toRow (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) = [toField a, toField b, toField c, toField d, toField e, toField f, toField g, toField h, toField i, toField j, toField k, toField l, toField m, toField n, toField o, toField p]
    fromRow [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p] = (,,,,,,,,,,,,,,,) <$> fromC a <*> fromC b <*> fromC c <*> fromC d <*> fromC e <*> fromC f <*> fromC g <*> fromC h <*> fromC i <*> fromC j <*> fromC k <*> fromC l <*> fromC m <*> fromC n <*> fromC o <*> fromC p
    fromRow _ = Nothing

----------------------------------------------------------------------------
-- Low-level internal details
----------------------------------------------------------------------------

{- | Helper function to help parse the rows and read the `InputStream` till its
end or fail early if the parsing fails.
-}
fromRows
    :: forall a m .
       (MonadIO m, Row a, WithError m)
    => ([SQL.FieldDef], Stream.InputStream [SQL.MySQLValue])
    -> m [a]
fromRows (_columnDefs, iStream) = go []
  where
    go :: [a] -> m [a]
    go acc = liftIO (Stream.read iStream) >>= \case
        -- There are no more rows to be read from the server
        Nothing -> pure acc  -- TODO: call reverse here? Otherwise returns in the reverse order
        -- There are still rows to be read from the server
        Just values -> case fromRow values of
            -- Parsing of current row succeeded. Recurse
            Just parsedValue -> go (parsedValue : acc)
            -- Parsing of the current row failed, error out
            Nothing -> do
                -- You need to 'consume' the while inputstream if we want to discard results midway
                -- to prevent errors
                liftIO $ SQL.skipToEof iStream
                throwError $ mysqlParseError (show values)
